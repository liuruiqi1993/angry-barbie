{"./":{"url":"./","title":"介绍","keywords":"","body":"My Book Welcome in my book! "},"js/":{"url":"js/","title":"Javascript","keywords":"","body":"Javascript "},"js/基础概念和简写问题.html":{"url":"js/基础概念和简写问题.html","title":"基础概念和简写问题","keywords":"","body":"概念和简写 基础概念 强弱类型语言 js是弱类型语言，因为同一个变量可以反复赋值，而且可以是不同类型的变量。 而强类型定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。 strict严格模式 强制要求用var申明变量。没有通过var申明就被使用，那么该变量就自动被申明为全局变量。 Truthy和Falsy null、undefined、0、NaN和空字符串''视为false，其他值一概视为true 循环 for break 结束当前层级的循环，外层继续。 continue 中止本次循环，接着开始下一次循环。 return 是用来结束函数的，如果for循环没有写在function中会报Illegal return statement。 for...in while () {} 每次循环开始的时候判断条件。 do {} while () 每次循环完成的时候判断条件,至少执行一次。 简写 不确定 const map = list.reduce((res, v) => (res[v.id] = v, res), {}) 逗号是什么意思，return res 总结 a && b() a = b || c 解构赋值: 数组 + 对象 + 字符串 [x, y] = [y, x]交换xy的值 扩展运算符...用于数组或对象浅拷贝，函数调用 三元运算 obj == null 可以用来检查 null || undefined 解构赋值 可以将属性/值从对象/数组中取出,赋值给其他变量。 let {a,b,c,...rest} = {a: 1,b: 2,c: 3,d: 4,e: 5} console.log(a,b,c,rest) // 1 2 3 {d: 4, e: 5} let [a,b,c,...rest] = [1,2,3,4,5] console.log(a,b,c,rest) // 1 2 3 [4, 5] let [a,b,c,...rest] = '12345' console.log(a,b,c,rest) // \"1\" \"2\" \"3\" [\"4\", \"5\"] ----------有问题分割线---------- let {a,b,c,...rest} = '12345' console.log(a,b,c,rest) // undefined undefined undefined {0: \"1\", 1: \"2\", 2: \"3\", 3: \"4\", 4: \"5\"} let {a,b,c,...rest} = 12345 console.log(a,b,c,rest) // undefined undefined undefined {} let [a,b,c,...rest] = 12345 console.log(a,b,c,rest) // error: 12345 is not iterable 扩展运算 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开； 还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。 浅拷贝 可替代Array.unshift，Array.concat，Object.assign let obj = {a: 1, b: 2, c: {d: 4}, e: [5]} let objClone = { g: 7, ...obj, f: 6 }; obj.b = 20 obj.c.d = 40 obj.e[0] = 50 console.log(objClone) // {g: 7, a: 1, b: 2, c: {d: 40}, e: [50], f: 6} let arr = [1, 2, {a: 3}, [4]] let arrClone = [ 7, ...arr, 5 ]; arr[1] = 20 arr[2].a = 30 arr[3][0] = 40 console.log(arrClone) // [7, 1, 2, {a: 30}, [40], 5] 函数调用 //等价于apply的方式 function myFunction(v, w, x, y, z) { } var args = [0, 1]; myFunction(-1, ...args, 2, ...[3]); //在 new 表达式中应用 var dateFields = [1970, 0, 1]; // 1970年1月1日 var d = new Date(...dateFields); https://www.cnblogs.com/allen2333/p/9835654.html export default function (source, length = 3) { source = String(source).split(\".\"); source[0] = source[0].replace(new RegExp('(\\\\d)(?=(\\\\d{'+length+'})+$)','ig'),\"$1,\"); return source.join(\".\"); } \\d是把\\d当作一个向后引用，先占位， 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 console.log(('100000000').replace(new RegExp('(\\\\d)((\\\\d{3})+$)','ig'),\"$1,$2 \")) 100,000000 (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。 (? $1匹配的是(\\d),$2匹配(?=(\\d{'+length+'})+$) console.log(('1000000000').replace(new RegExp('(\\\\d)(?=(\\\\d{3})+$)','ig'),\"$1,$2 \")) 1,000 000,000 000,000 000 "},"js/arrayzongjie.html":{"url":"js/arrayzongjie.html","title":"Array总结","keywords":"","body":"Array总结 一个问题不能栽倒N次 参考MDN 所有的回调中，如果有thisArg，那么回调函数的this值就是thisArg。只对function(){}有效，对箭头函数不起作用。 返回新数组 Array.concat() 浅拷贝 var arr = ['A', 'B', 'C']; arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] Array.from() console.log(Array.from('foo')); // expected output: Array [\"f\", \"o\", \"o\"] console.log(Array.from([1, 2, 3], x => x + x)); // expected output: Array [2, 4, 6] Array.fill() 语法：arr.fill(value[, start[, end]]) Array.filter() 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 Array.flat() 替代方案：使用 reduce 与 concat 深度递归遍历数组 var arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); // [1, 2, 3, 4, [5, 6]] var arr3 = [1, 2, [3, 4, [5, 6]]]; arr3.flat(2); // [1, 2, 3, 4, 5, 6] //使用 Infinity，可展开任意深度的嵌套数组 var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]; arr4.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 移除空项 var arr4 = [1, 2, [3, 4, [5,, 6,, [7, ,8, [9,, 10]]]]]; arr4.flat(Infinity) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Array.flatMap() 与map()相似，替代方案：使用 reduce 与 concat var arr1 = [1, 2, 3, 4]; console.log(arr1.flatMap(x => x * 2)); // [2, 4, 6, 8] console.log(arr1.flatMap(x => [x * 2])); // [2, 4, 6, 8] console.log(arr1.flatMap(x => [[x * 2]])); // [[2], [4], [6], [8]] Array.slice() 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝 改变原数组 Array.copyWithin() 浅复制数组的一部分到同一数组中的另一个位置 [1, 2, 3, 4, 5].copyWithin(-2) // [1, 2, 3, 1, 2] [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(-2, -3, -1) // [1, 2, 3, 3, 4] [].copyWithin.call({length: 5, 3: 1}, 0, 3); // {0: 1, 3: 1, length: 5} Array.pop() 删除最后一个元素，并返回该元素的值。 Array.push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 Array.reverse() Array.shift() 方法从数组中删除第一个元素，并返回该元素的值。 Array.unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度。 Array.sort() 9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 \"80\" 要比 \"9\" 要靠前。 对非 ASCII 字符排序 var items = ['réservé', 'premier', 'cliché', 'communiqué', 'café', 'adieu']; items.sort(function (a, b) { return a.localeCompare(b); }); // items is ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé'] Array.splice() 返回由被删除的元素组成的一个数组。 合成字符串 Array.join() Array.toLocaleString() const array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')]; const localeString = array1.toLocaleString('en', {timeZone: \"UTC\"}); console.log(localeString); // expected output: \"1,a,12/21/1997, 2:12:00 PM\", var prices = ['￥7', 500, 8123, 12]; prices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' }); // \"￥7,￥500,￥8,123,￥12\" Array.toString() 返回一个用逗号相隔的字符串。 判断 Array.every() 一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 Array.isArray() Array.includes() 语法：arr.includes(valueToFind[, fromIndex]) 如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。 Array.some() 如果用一个空数组进行测试，在任何情况下它返回的都是false。callback返回真值时结束。 查找 Array.find() 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 Array.findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 Array.indexOf() 语法：arr.indexOf(searchElement[, fromIndex]) 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。为负数也是从前往后查。 Array.lastIndexOf() 语法：arr.lastIndexOf(searchElement[, fromIndex]) 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。为负数也是从后往前查。 遍历 若你需要提前终止循环，你可以使用： 一个简单的 for 循环 for...value...of / for...key...in 循环 Array.every()直到falsy Array.some()直到truthy Array.find() Array.findIndex() Array.filter() + Array.forEach() (forEach本身只能通过抛出错误来中止) Array.keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。 Array.values() 方法返回一个包含数组中每个索引值的Array Iterator对象。 Array.entries() 返回一个新的 Array 迭代器(Array Iterator)对象， 对象上有next()方法，next()返回一个对象，对象的value对应的值是[\"key\",\"value\"] 二维数组按行排序 function sortArr(arr) { var goNext = true; var entries = arr.entries(); while (goNext) { var result = entries.next(); if (result.done !== true) { result.value[1].sort((a, b) => a - b); goNext = true; } else { goNext = false; } } return arr; } var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]]; sortArr(arr); /*(4) [Array(2), Array(5), Array(5), Array(4)] 0:(2) [1, 34] 1:(5) [2, 3, 44, 234, 456] 2:(5) [1, 4, 5, 6, 4567] 3:(4) [1, 23, 34, 78] length:4 __proto__:Array(0) */ 使用for…of 循环 var arr = [\"a\", \"b\", \"c\"]; var iterator = arr.entries(); // undefined for (let e of iterator) { console.log(e); } // [0, \"a\"] // [1, \"b\"] // [2, \"c\"] Array.forEach() 方法对数组的每个元素执行一次给定的函数。没有返回值，已删除或者未初始化的项将被跳过，并且不可链式调用，除了抛出异常以外，没有办法中止或跳出 forEach() 循环。 Array.map() 返回一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。 map会跳过空项，如果没有返回值就是undefined var numbers = [1, 8, 4,7,10,, 9]; var doubles = numbers.map(function(num,index) { if(!(index%2)) { // 如果写!index%2，就会算成(!index)%2， 结果就是[2, undefined, undefined, undefined, undefined, empty, undefined] console.log(num, index%2) return num * 2 }; }); console.log(doubles) // 1 0 // 4 0 // 10 0 // 9 0 // [2, undefined, 8, undefined, 20, empty, 18] Array.reduce() 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 空数组必须有initialValue。 按顺序运行Promise Array.reduceRight() 与reduce是相反方向。 筛选查找总结 要查找的元素可能是基础类型String，Number，也可能是Objet，Array。 后者只能通过callback去判断它是不是符合条件 var array = [['a', 'b'], 'a', 'c', 'a', 'd']; var element = ['a', 'b']; console.log(array.indexOf(element)) // -1 是否都：every返回布尔值 有没有： includes，基础类型 indexOf 有就返回索引，没有-1 some，返回布尔值 find 有就返回值，没有undefined findIndex，有就返回索引，没有-1 有哪些：filter返回符合条件的数组 "},"js/function.html":{"url":"js/function.html","title":"Function总结","keywords":"","body":"Function总结 基础 作用域： 函数体 全局作用域只有一个。 语法new Function ([arg1[, arg2[, ...argN]],] functionBody) arguments 是一个对应于传递给函数的参数的类数组对象，最常用于判断传入参数的个数。。 arguments.callee 指向当前执行的函数。 arguments.length 指向传递给当前函数的参数数量。 Function.caller 获取调用函数的具体对象。该特性是非标准的，请尽量不要在生产环境中使用它！ Function.length 获取函数的接收参数个数。 Function.name 获取函数的名称。 变量提升 提升声明但不会提升赋值。 函数提升 //函数声明式，提到作用域最前面 function bar () {} //函数字面量式 与变量提升一致，定义后才能console，否则undefined var foo = function () {} 箭头函数 箭头函数内部的this是词法作用域，由上下文确定。 用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略。 剩余参数 如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组。 function(a, b, ...theArgs) { // ... } 剩余参数和 arguments对象的区别 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments对象不是一个真正的数组，而剩余参数是真正的Array实例。 arguments对象还有一些附加的属性（如callee属性）。 闭包 闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 函数1返回一个函数2，通过调用函数2可以访问函数1里的变量。 // 定义数字0: var zero = function (f) { return function (x) { return x; } }; // zero(f)(x) = x // 定义数字1: var one = function (f) { return function (x) { return f(x); } }; // one(f)(x) = f(x) // 定义加法: m,n换过来也没有关系 function add(n, m) { return function (f) { return function (x) { return m(f)(n(f)(x)); } } } // add(n,m)(f)(x) = m(f)(n(f)(x)) // 计算数字2 = 1 + 1: var two = add(one, one); // two(f)(x) = one(f)(one(f)(x)) = one(f)(f(x)) = f(f(x)) // 计算数字3 = 1 + 2: var three = add(one, two); // three(f)(x) = two(f)(one(f)(x)) = f(f(one(f)(x))) = f(f(f(x))) // 计算数字5 = 2 + 3: var five = add(two, three); // five(f)(x) = three(f)(two(f)(x)) = f(f(f(two(f)(x)))) = f(f(f(f(f(x))))) five = add(three, two) // five(f)(x) = two(f)(three(f)(x)) = f(f(three(f)(x))) = f(f(f(f(f(x))))) 构造函数 用new调用，返回一个对象的函数。 function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); } } new一个对象具体做了什么 当以new关键字调用时，会创建一个新的内存空间，标记为 Animal 的实例。 函数体内部的 this 指向该内存 执行函数体内的代码，给this添加属性和方法 默认返回this "},"js/map,setiterable.html":{"url":"js/map,setiterable.html","title":"Map,Set和iterable","keywords":"","body":"Map,Set和iterable Map Map是一组键值对的结构，具有极快的查找速度。初始化Map需要一个二维数组。 一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。 var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value m.has('Adam'); // 是否存在key 'Adam': true m.get('Adam'); // 67 m.delete('Adam'); // 删除key 'Adam' 将Object转换为Map var obj = { foo: \"bar\", baz: 42 }; var map = new Map(Object.entries(obj)); console.log(map); // Map { foo: \"bar\", baz: 42 } 将Map转换为Object const entries = new Map([ ['foo', 'bar'], ['baz', 42] ]); const obj = Object.fromEntries(entries); console.log(obj); // expected output: Object { foo: \"bar\", baz: 42 } Set 一组key的集合，但不存储value。由于key不能重复。 var s = new Set([1, 2, 3]); s.add(4); s.delete(3); 数组去重 Array.from(new Set(array)) iterable 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of和forEach循环来遍历。 var s = new Set(['A', 'B', 'C']); s.forEach(function (element, sameElement, set) { console.log(element); }); var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); m.forEach(function (value, key, map) { console.log(value); }); var a = ['A', 'B', 'C']; a.forEach(function (element) { console.log(element); }); "},"js/number.html":{"url":"js/number.html","title":"Number总结","keywords":"","body":"Number总结 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) "},"js/object.html":{"url":"js/object.html","title":"Object总结","keywords":"","body":"Object总结 对象的属性分为可枚举和不可枚举，他们是由property的enumerable值决定的。能被for...in到的就是可枚举。 function Person() { this.name = 'a' this.age = 'b' } function Parent(){ this.hobby = \"c\" } Parent.prototype = new Person() let child = new Parent() console.log(child) for (let key in child){ console.log(key) } // Parent {hobby: \"c\"} // hobby // name // age let ab = Object.create(child, {'property2': { value: 'Hello', writable: false }}) console.log(ab) for (let key in ab){ console.log(key) } // Person {property2: \"Hello\"} // hobby // name // age 设定和获取设定 //////////////////// Object.seal() 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。返回被密封的对象。 使用Object.freeze()冻结的对象中的现有属性值是不可变的。用Object.seal()密封的对象可以改变其现有属性值。 const object1 = { property1: 42 }; Object.seal(object1); object1.property1 = 33; console.log(object1.property1); // expected output: 33 Object.isSealed() 方法判断一个对象是否被密封。 Object.freeze() 冻结一个对象后该对象的原型也不能被修改。返回被冻结的对象。 如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。 const obj = { prop: 42 }; Object.freeze(obj); obj.prop = 33; // Throws an error in strict mode console.log(obj.prop); // expected output: 42 Object.isFrozen() 判断一个对象是否被冻结。 Object.preventExtensions() 让一个对象变的不可扩展，也就是永远不能再添加新的属性。不可扩展的对象。 Object.isExtensible() 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展。 //////////////////// Object.defineProperty() 精确地添加或修改对象的属性。 语法：Object.defineProperty(obj, prop, descriptor) 返回obj。 function Archiver() { var temperature = null; var archive = []; Object.defineProperty(this, 'temperature', { get: function() { console.log('get!'); return temperature; }, set: function(value) { temperature = value; archive.push({ val: temperature }); } }); this.getArchive = function() { return archive; }; } var arc = new Archiver(); arc.temperature; // 'get!' arc.temperature = 11; arc.temperature = 13; arc.getArchive(); // [{ val: 11 }, { val: 13 }] Object.getOwnPropertyDescriptor() 返回指定对象上一个自有属性对应的属性描述符(对象)。不需要从原型链上进行查找的属性。 Object.defineProperties() 一次定义多个 语法：Object.defineProperties(obj, props) 返回props。 var obj = {}; Object.defineProperties(obj, { 'property1': { value: true, writable: true }, 'property2': { value: 'Hello', writable: false } // etc. etc. }); Object.getOwnPropertyDescriptors() 一个对象的所有自身属性的描述符。 //////////////////// Object.hasOwnProperty() 会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。 Object.getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。 var arr = [\"a\", \"b\", \"c\"]; console.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"] 只获取不可枚举的属性 var target = myObject; var enum_and_nonenum = Object.getOwnPropertyNames(target); var enum_only = Object.keys(target); var nonenum_only = enum_and_nonenum.filter(function(key) { var indexInEnum = enum_only.indexOf(key); if (indexInEnum == -1) { // 没有发现在enum_only健集中意味着这个健是不可枚举的, // 因此返回true 以便让它保持在过滤结果中 return true; } else { return false; } }); console.log(nonenum_only); Object.getOwnPropertySymbols() 返回一个给定对象自身的所有 Symbol 属性的数组。 //////////////////// Object.getPrototypeOf() 返回给定对象的原型。 var proto = {}; var obj = Object.create(proto); Object.getPrototypeOf(obj) === proto; // true var reg = /a/; Object.getPrototypeOf(reg) === RegExp.prototype; // true Object.isPrototypeOf() 调用对象是否在另一个对象的原型链上。返回布尔值。 Object.setPrototypeOf() 设置一个指定的对象的原型。 更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。 你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。 //////////////////// Object.propertyIsEnumerable() 返回一个布尔值，表示指定的属性是否可枚举。 新对象 Object.assign() 将所有可枚举属性的值从一个或多个源对象复制到目标对象。浅拷贝 Object.create() 创建一个新对象，使用现有的对象来提供新创建的对象的proto。浅拷贝 判断 Object.is() 判断两个值是否相同。如果下列任何一项成立，则两个值相同： 两个值都是 undefined 两个值都是 null 两个值都是 true 或者都是 false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且 都是正零 +0 都是负零 -0 都是 NaN 都是除零和 NaN 外的其它同一个数字 这种相等性判断逻辑和传统的 == 运算不同，== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 \"\" == false 等于 true 的现象），但 Object.is 不会做这种类型转换。 Object.is(window, window); // true Object.is([], []); // false Object.is(0, -0); // false Object.is(0, +0); // true Object.is(NaN, 0/0); // true 遍历 for...key...in 可枚举 Object.keys() 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致。 Object.values() 返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同。 Object.entries() 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 // getFoo is property which isn't enumerable const myObj = Object.create({}, { getFoo: { value() { return this.foo; } } }); myObj.foo = 'bar'; console.log(Object.entries(myObj)); // [ ['foo', 'bar'] ] // non-object argument will be coerced to an object console.log(Object.entries('foo')); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ] 将Object转换为Map var obj = { foo: \"bar\", baz: 42 }; var map = new Map(Object.entries(obj)); console.log(map); // Map { foo: \"bar\", baz: 42 } 将Map转换为Object const entries = new Map([ ['foo', 'bar'], ['baz', 42] ]); const obj = Object.fromEntries(entries); console.log(obj); // expected output: Object { foo: \"bar\", baz: 42 } JSON JSON.stringify() var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'] }; // 1转换对象 // 2需要的字段，也可以是函数 // 3缩进 JSON.stringify(xiaoming, ['name', 'skills'], ' '); 想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据： var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON () { return { // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age }; } }; JSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}' JSON.parse() JSON.parse()还可以接收一个函数，用来转换解析出的属性： var obj = JSON.parse('{\"name\":\"小明\",\"age\":14}', (key, value) => { if (key === 'name') { return value + '同学'; } return value; }); console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14} "},"js/storage.html":{"url":"js/storage.html","title":"Storage","keywords":"","body":"Storage cookie 目的 用于识别用户身份。 特点 4kb 发请求自动带上 原理 服务器返回setsCookie时，浏览器会记住cookie, 浏览器发送请求，cookie会被携带给服务器。 Cookie 执行同源策略，同一个 host 下的不同端口可以互相访问 Cookie。a与b只能访问自己的cookie，在a中内嵌c网页，并获取c的cookie，此时c cookie是a的第三方cookie。 Chrome 更新 80后， SameSite 为Lax， 仅允许同站或者子站访问Cookie, 跨站（内嵌c无法访问cookie）需要SameSite None Secure：只允许Https setCookie HttpOnly： 不允许JS访问ducoment.cookie， 只能由服务器setsCookie Set-Cookie: userId=123; SameSite=None; Secure; HttpOnly 应用 多用于广告服务。a通过内嵌网页向c发送请求，c返回cookie；b通过内嵌网页向c发送请求，并携带cookie，c获知用户身份，按喜好投放广告。 缺点 XSS攻击： 跨站脚本攻击， 利用用户对网页的信任。不设置HttpOnly，则用户能上传恶意代码，如： window.open(\"举个栗子.com?cookie=\" + document.cookie，获取他人的cookie与身份。 CSRF(Cross-site request forgery): 跨站请求伪造，需要诱导点击，利用跨域发请求，携带cookie，完成非意愿的操作。 storage 目的 弥补cookie太小 特点 10MB 使用 Key-Value 形式储存， 只能存字符串。 需要调用setItem, getItem, removeItem, clear。 增删改查为同步。 IndexedDB 目的 弥补storage只能存字符串 特点 空间无限制。 能存对象，数字等。 增删改查都是异步。 [文档] (https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB) IndexedDB 鼓励使用的基本模式如下所示： 1. 打开数据库。 2. 在数据库中创建一个对象仓库（object store）。 3. 启动一个事务，并发送一个请求来执行一些数据库操作，像增加或提取数据等。 4. 通过监听正确类型的 DOM 事件以等待操作完成。 5. 在操作结果上进行一些操作 const dbName = \"the_name\"; var request = indexedDB.open(dbName, 2); request.onerror = function(event) { // 错误处理 }; request.onsuccess = function(event) { // 成功 console.log(event.target.result) }; // 当你创建一个新的数据库或者增加已存在的数据库的版本号（当打开数据库时，指定一个比之前更大的版本号）， onupgradeneeded 事件会被触发, onupgradeneeded 是我们唯一可以修改数据库结构的地方。 request.onupgradeneeded = function(event) { var db = event.target.result; // 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path） // 因为 ssn 可以保证是不重复的 // autoIncrement 自增 var objectStore = db.createObjectStore(\"customers\", { keyPath: \"ssn\", autoIncrement : true }); // 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引 objectStore.createIndex(\"name\", \"name\", { unique: false }); // 使用邮箱建立索引，我们向确保客户的邮箱不会重复，所以我们使用 unique 索引 objectStore.createIndex(\"email\", \"email\", { unique: true }); // 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕 objectStore.transaction.oncomplete = function(event) { // 将数据保存到新创建的对象仓库 var customerObjectStore = db.transaction(\"customers\", \"readwrite\").objectStore(\"customers\"); // 增 customerData.forEach(function(customer) { let add = customerObjectStore.add(customer); add.onsuccess = () => {} add.onerror = () => {} }); // 改 let put = customerObjectStore.put(data) put.onsuccess = () => {} put.onerror = () => {} // 删 let remove = customerObjectStore.delete(\"444-44-4444\") remove.onsuccess = () => {} remove.onerror = () => {} // 查 let get = customerObjectStore.get(\"444-44-4444\") get.onsuccess = () => {} get.onerror = () => {} }; }; "},"js/string.html":{"url":"js/string.html","title":"String总结","keywords":"","body":"String总结 ASCII字符可以以\\x##形式的十六进制表示，例如： '\\x41'; // 完全等同于 'A' 还可以用\\u####表示一个Unicode字符： '\\u4e2d\\u6587'; // 完全等同于 '中文' 新字符串 "},"js/this.html":{"url":"js/this.html","title":"this指向","keywords":"","body":"this指向 https://juejin.cn/post/6925082635442225160 指向 被调用的对象。 function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25, 正常结果 window.getAge(); // NaN 因为 y - undefined var fn = xiaoming.age; // 先拿到xiaoming的age函数 window.fn(); // NaN this还是window this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！） 'use strict'; var xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); } }; xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined apply()， bind()，call() call()、apply()、bind() 都是用来重定义 this 这个对象的。 bind 返回的是一个新的函数，你必须调用它才会被执行。 obj.myFun.call(db,'成都','上海')； // 德玛 年龄 99 来自 成都去往上海 obj.myFun.apply(db,['成都','上海']); // 德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,'成都','上海')(); // 德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,['成都','上海'])();// 德玛 年龄 99 来自 成都, 上海去往 undefined new绑定>显式绑定>隐式绑定>默认绑定 同时我们可以得出一套规律： 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 函数是否通过 call、apply、bind（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。 1.硬绑定 硬绑定属于显式绑定的一个变种，但是却可以解决这个问题。在函数 bar()中，我们调用了 foo.call(obj)，这样会强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，this都会再次绑定到obj。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。 function foo() {console.log( this.a ); } var obj = { a:2 }; var bar = function() { foo.call( obj ); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2 2.API调用上下文 第三方库的许多函数，以及 JS语言和环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”，其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。 function foo(id) { console.log( id, this.id ); } var obj = { id: \"dmeo\" }; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 demo 2 demo3 demo "},"js/filetype.html":{"url":"js/filetype.html","title":"文件格式","keywords":"","body":"文件格式 MIME \"Multipurpose Internet Mail Extensions\"，中译为\"多用途互联网邮件扩展\"，指的是一系列的电子邮件技术规范。 早期的邮件只能只能使用ASCII字符，不能发图片和附件。 所以用Content-Type来标记文件格式。它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用\"/\"分割。主要类型有9种，分别是application、audio、example、image、message、model、multipart、text、video。 如果信息的主要类型是\"text\"，那么还必须指明编码类型\"charset\"，缺省值是ASCII，其他可能值有\"ISO-8859-1\"、\"UTF-8\"、\"GB2312\"等等。 text/plain：charset=\"ISO-8859-1\"：纯文本，文件扩展名.txt text/html：HTML文本，文件扩展名.htm和.html image/jpeg：jpeg格式的图片，文件扩展名.jpg image/gif：GIF格式的图片，文件扩展名.gif audio/x-wave：WAVE格式的音频，文件扩展名.wav audio/mpeg：MP3格式的音频，文件扩展名.mp3 video/mpeg：MPEG格式的视频，文件扩展名.mpg application/zip：PK-ZIP格式的压缩文件，文件扩展名.zip MIME用Content-transfer-encoding将8位的非英语字符转化为7位的ASCII字符。 可选值有\"7bit\"、\"8bit\"、\"binary\"、\"quoted-printable\"和\"base64\"----其中\"7bit\"是缺省值，即不用转化的ASCII字符。 真正常用是\"quoted-printable\"和\"base64\"两种。 Quoted-printable 用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。 它将每一个8位的字节，转换为3个字符，第一个字符是\"=\"号，这是固定不变的。后面二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。 举例来说，ASCII码中\"换页键\"（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为\"=0C\"。\"=\"号的ASCII值是61，二进制形式是00111101，因为它的编码值是\"=3D\"。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。 base64 选出64个字符----小写字母a-z、大写字母A-Z、数字0-9、符号\"+\"、\"/\"（再加上作为垫字的\"=\"，实际上是65个字符）----作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。 好处 所有的二进制文件，都可以因此转化为可打印的文本编码，使用文本软件进行编辑； 能够对文本进行简单的加密。 原理 Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右。 Text contentManASCII7797110Bit pattern010011010110000101101110Index1922546Base64-EncodedTWFu 第一步，\"M\"、\"a\"、\"n\"的ASCII值分别是77、97、110，对应的二进制值是01001101、01100001、01101110，将它们连成一个24位的二进制字符串010011010110000101101110。 第二步，将这个24位的二进制字符串分成4组，每组6个二进制位：010011、010110、000101、101110。 第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节：00010011、00010110、00000101、00101110。它们的十进制值分别是19、22、5、46。 第四步，根据上表，得到每个值对应Base64编码，即T、W、F、u。 两个字节时 将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个\"=\"号。 0100110101100001 = 010011 + 010110 + 0001 = 00010011 + 00010110 + 00010000 = T + W + E = TWE= 一个字节时 这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个\"=\"号。 01001101 = 010011 + 01 = 00010011 + 00010000 = T + Q = TQ== 中文字符 汉字本身可以有多种编码，比如gb2312、utf-8、gbk等等，每一种编码的Base64对应值都不一样。下面的例子以utf-8为例。 \"严\"的utf-8编码为E4B8A5，写成二进制就是三字节的\"11100100 10111000 10100101\"，转换成四组一共32位的二进制值\"00111001 00001011 00100010 00100101\"，相应的十进制数为57、11、34、37，它们对应的Base64值就为5、L、i、l。 编码解码 Javascript内部的字符串，都以utf-16的形式进行保存，因此编码的时候，我们首先必须将utf-8的值转成utf-16再编码，解码的时候，则是解码后还需要将utf-16的值转回成utf-8。 http://www.ruanyifeng.com/blog/2008/06/base64.html "},"js/async&await&generator.html":{"url":"js/async&await&generator.html","title":"async, await, generator","keywords":"","body":"async, await, generator 一个generator看上去像一个函数，但可以返回多次。调用generator对象有两个方法： function* foo(x) { yield x + 1; yield x + 2; return x + 3; } 用for ... of循环迭代generator对象 调用generator对象的next()方法，返回一个对象{value: x, done: true/false}，value就是yield的返回值，done表示这个generator是否已经执行结束了。下一次调用next的时候，传的参数会被作为上一个yield前面接受的值 const getData = () => new Promise(resolve => setTimeout(() => resolve(\"data\"), 1000)) function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return 'success' } var gen = testG() gen.next('这个参数才会被赋给data变量') gen.next('666') // data: 666 // {value: Promise, done: false} async await https://juejin.im/post/5e79e841f265da5726612b6e "},"js/input.html":{"url":"js/input.html","title":"input事件顺序","keywords":"","body":"input如何处理中文输入，事件顺序 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/129 输入到input框触发input事件 失去焦点后内容有改变触发change事件 识别到你开始使用中文输入法触发compositionstart 事件 未输入结束但还在输入中触发compositionupdate事件 输入完成（也就是我们回车或者选择了对应的文字插入到输入框的时刻）触发compositionend事件。 复制粘贴中文内容的时候不会触发composition事件, 用onpaste 参考vue源码对v-model的实现中，对输入中文的处理 function jeiliu(timeout){ var timer; function input(e){ if(e.target.composing){ return ; } if(timer){ clearTimeout(timer); } timer = setTimeout(() => { console.log(e.target.value); timer = null; }, timeout); } return input; } function onCompositionStart(e){ e.target.composing = true; } function onCompositionEnd(e){ //console.log(e.target) e.target.composing = false; var event = document.createEvent('HTMLEvents'); event.initEvent('input'); e.target.dispatchEvent(event); } var input_dom = document.getElementById('myinput'); input_dom.addEventListener('input',jeiliu(1000)); input_dom.addEventListener('compositionstart',onCompositionStart); input_dom.addEventListener('compositionend',onCompositionEnd); "},"js/异步加载.html":{"url":"js/异步加载.html","title":"异步加载","keywords":"","body":"异步加载和Promise 在JavaScript的世界中，所有代码都是单线程执行的，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现。异步操作会在将来的某个时间点触发一个函数调用。 function test(resolve, reject) { var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () { if (timeOut https://www.cnblogs.com/xiaojianwei/p/12209471.html Promise 变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行完毕，p1就能调用then和catch var p1 = new Promise(test); job1.then(job2).then(job3).catch(handleError); // job1、job2和job3都是Promise对象 Promise.race([p1, p2]).then(function (result) {}); Promise.all([p1, p2]).then(function (result) {}); "},"js/深浅拷贝.html":{"url":"js/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"深浅拷贝 https://segmentfault.com/a/1190000008637489 https://juejin.im/post/5a00226b5188255695390a74 https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1 https://www.cnblogs.com/xiaojianwei/p/12209147.html "},"js/MVC与MVVM的区别.html":{"url":"js/MVC与MVVM的区别.html","title":"MVC与MVVM的区别","keywords":"","body":"MVC与MVVM的区别 https://www.php.cn/faq/417707.html MVC MVC是包括view视图层、controller控制层、model数据层。各部分之间的通信都是单向的。 View 传送指令到 ControllerController 完成业务逻辑后，要求 Model 改变状态Model 将新的数据发送到 View，用户得到反馈 MVVM MVVM包括view视图层、model数据层、viewmodel层。各部分通信都是双向的。采用双向数据绑定，View的变动，自动反映在 ViewModel，反之亦然。其中ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层 MVC与MVVM的区别 在MVC里，View是可以直接访问Model的，所以View里会包含Model信息以及一些业务逻辑。 MVC模型关注的是Model的不变，所以在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。 MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。此外MVVM另一个重要特性双向绑定，它更方便你去同时维护页面上都依赖于某个字段的N个区域，而不用手动更新它们。 "},"js/window.html":{"url":"js/window.html","title":"window","keywords":"","body":"Window 方法 | open() | 打开一个新的浏览器窗口或查找一个已命名的窗口。| | close() | 关闭浏览器窗口。通过 JavaScript 代码打开的窗口才能够由 JavaScript 代码关闭。| | print() | 打印当前窗口的内容。| | confirm() | 显示带有一段消息以及确认按钮和取消按钮的对话框。confirm(\"提示!\")是布尔值| | prompt() | 显示可提示用户输入的对话框。prompt(\"提示\",\"placeholder\")是String | 事件 onload DOMContentLoaded 与onload区别以及使用 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。 navigator 浏览器信息 navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 location | assign() | 加载新的文档。| | reload() | 重新加载当前文档。| | replace() | 用新的文档替换当前文档。| screen | availHeight | 返回显示屏幕的高度 (除 Windows 任务栏之外)。 | | availWidth | 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 | | bufferDepth | 设置或返回调色板的比特深度。 | | colorDepth | 返回目标设备或缓冲器上的调色板的比特深度。 | | deviceXDPI | 返回显示屏幕的每英寸水平点数。 | | deviceYDPI | 返回显示屏幕的每英寸垂直点数。 | | fontSmoothingEnabled | 返回用户是否在显示控制面板中启用了字体平滑。 | | height | 返回显示屏幕的高度。 | | logicalXDPI | 返回显示屏幕每英寸的水平方向的常规点数。 | | logicalYDPI | 返回显示屏幕每英寸的垂直方向的常规点数。 | | pixelDepth | 返回显示屏幕的颜色分辨率（比特每像素）。 | | updateInterval | 设置或返回屏幕的刷新率。 | | width | 返回显示器屏幕的宽度。 | document 增 document.createElement element.appendChild 语法node.appendChild(node) element.insertBefore 语法node.insertBefore(newnode,existingnode) 在node中的existingnode前插入newnode 如果你想创建一个新的文本列表项， 首先创建一个节点， 然后创建一个文本节点， 然后将文本节点添加到LI节点上。 最后将节点添加到列表中。 var node=document.createElement(\"LI\"); var textnode=document.createTextNode(\"Water\"); node.appendChild(textnode); document.getElementById(\"myList\").appendChild(node); 删 首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 例如，对于如下HTML结构： First Second 当我们用如下代码删除子节点时： var parent = document.getElementById('parent'); parent.removeChild(parent.children[0]); parent.removeChild(parent.children[1]); // 浏览器报错：parent.children[1]不是一个有效的节点。原因就在于，当First节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了。 因此，删除多个节点时，要注意children属性时刻都在变化。 改 element.innerHTML 不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树 如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 element.innerText 不返回隐藏元素的文本 textContent 返回所有文本，> IE9 element.style 驼峰式命名 查 getElementById() getElementsByClassName() getElementsByTagName() querySelector() querySelectorAll() document.write, document.open, document.close document.open, document.close的作用就是打开输出流。 文档在加载的过程中实际是一边加载一边用 document.write 写出内容到屏幕上，而加载完成后，输出流关闭，再调用 document.write 往网页上写内容的话，就会重写 document。 JavaScript 能够直接写入 HTML 输出流中： document.write(\"This is a heading\"); document.write(\"This is a paragraph.\"); 您只能在 HTML 输出流中使用 document.write。 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。 点击这里 function myFunction() { document.write(\"调用了函数，之前的文档被重写\"); } 没有close的话，标签页头一直转，加载中 var w=window.open(); w.document.open(); w.document.write(\"Hello World!\"); w.document.write(\"Hello World!\"); w.document.close(); document.readyState readyState 属性返回当前文档的状态，返回以下值: uninitialized - 还未开始载入 loading - 载入中 interactive - 已加载，文档与用户可以开始交互 complete - 载入完成 document.scripts 返回文档中所有 元素的集合。 history | back() | 加载 history 列表中的前一个 URL。| | forward() | 加载 history 列表中的下一个 URL。| | go() | 加载 history 列表中的某个具体页面。| "},"js/yuanxing.html":{"url":"js/yuanxing.html","title":"原型与原型链","keywords":"","body":"原型和继承 JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。 关系 实例.__proto__ === 构造函数.prototype === 原型 原型.constructor === 构造函数 构造函数 new一个对象具体做了什么 每个new出来的this储存地址都不一样（this1.function !== this2.function）造成空间浪费，所以公用方法放在原型上。每一个实例都能访问到这个方法。 原型继承 对于Class而言，继承的本质是扩展一个已有的Class，并生成新的Subclass。 基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent： function PrimaryStudent(props) { // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1; } 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null 必须想办法把原型链修改为： new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null 所以加上PrimaryStudent.prototype = new Student() 创建对象的方式 https://baijiahao.baidu.com/s?id=1611119750903121416&wfr=spider&for=pc 工厂模式 缺点：没有解决对象识别问题，即不能知道一个对象的类型。 person1 instanceof Person === false, person1 instanceof Object === true function createPerson(name,age,job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var person1 = createPerson('Nike',29,'teacher'); var person2 = createPerson('Arvin',20,'student'); person1.__proto__ ----> Object.prototype ----> null person2.__proto__ ----> Object.prototype ----> null 原型模式 缺点：实例相互影响 function Parent1() { this.name = ['super1'] this.reName = function () { this.name.push('super111') } } function Child1() { } Child1.prototype = new Parent1() var child11 = new Child1() var child12 = new Child1() child11.reName() console.log(child11.name, child12.name) // [ 'super1', 'super111' ] [ 'super1', 'super111' ] child11.__proto__ ----> Child1.prototype ----> Parent1.prototype ----> Object.prototype ----> null child12.__proto__ ----> Child1.prototype ----> Parent1.prototype ----> Object.prototype ----> null 构造函数模式 缺点：方法不共用，内存浪费 function Child2() { Parent1.call(this) } var child21 = new Child2() var child22 = new Child2() child21.reName() console.log(child21.name, child22.name) // [ 'super1', 'super111' ] [ 'super1' ], 子实例的属性都是相互独立的 console.log(child21.reName === child22.reName) \u000b// false, 实例方法也是独立的，没有共享同一个方法 child21.__proto__ ----> Child2.prototype ----> Object.prototype ----> null child22.__proto__ ----> Child2.prototype ----> Object.prototype ----> null 混合构造函数和原型模式 缺点: 父类构造函数被调用两次,子类实例的属性存在两份。造成内存浪费 function Parent3() { this.name = ['super3'] } Parent3.prototype.reName = function() { this.name.push('super31') } function Child3() { Parent3.call(this) // 生成子类的实例属性(但是不包括父对象的方法) } Child3.prototype = new Parent3() // 继承父类的属性和方法(副作用: 父类的构造函数被调用的多次，且属性也存在两份造成了内存浪费) var child31 = new Child3() var child32 = new Child3() child31.reName() console.log(child31.name, child32.name) // [ 'super3', 'super31' ] [ 'super3' ], 子类实例不会相互影响 console.log(child31.reName === child32.reName) //true, 共享了父类的方法 child31.__proto__ ----> Child3.prototype ----> Parent3.prototype ----> Object.prototype ----> null child32.__proto__ ----> Child3.prototype ----> Parent3.prototype ----> Object.prototype ----> null 寄生构造函数模式 完美：子类都有各自的实例不会相互影响，且共享了父类的方法 function Parent4() { this.name = ['super4'] } Parent4.prototype.reName = function() { this.name.push('super41') } function Child4() { Parent4.call(this) // 生成子类的实例属性(但是不包括父对象的方法) } Child4.prototype = Object.create(Parent4.prototype) // 该方法会使用指定的原型对象及其属性去创建一个新的对象 var child41 = new Child4() var child42 = new Child4() child41.reName() console.log(child41.name, child42.name) //[ 'super4','super41' ] [ 'super4' ], 子类实例不会相互影响 console.log(child41.reName === child42.reName) //true, 共享了父类的方法 child41.__proto__ ----> Child4.prototype ----> 浅拷贝Parent4.prototype ----> Object.prototype ----> null child42.__proto__ ----> Child4.prototype ----> 浅拷贝Parent4.prototype ----> Object.prototype ----> null 稳妥构造函数模式 没有公共属性 不使用this 不使用new调用 function Person(name,age,job){ //创建要返回的对象 var o=new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName=function(){ alert(name); } //返回对象 return o; } var friend=Person(\"Nicholas\",29,\"Software Engineer\"); friend.sayName();//\"Nicholas\" 动态原型模式 使用if语句，使得原型方法只初始化一次 function Person(name, age) { this.name = name this.age = age //这里只需要使用任何一个方式或属性，不一定是getName，getAge也可以 //只要保证if里面的代码只执行一次就行 if(typeof this.getName !== 'function') { Person.prototype.getName = function() { console.log(this.name) } Person.prototype.getAge = function() { console.log(this.age) } } } var person = new Person(\"AAA\", 23) person.getName() //AAA class class Parent5 { constructor() { this.name = ['super5'] } reName() { this.name.push('new 5') } } class Child5 extends Parent5 { constructor() { super() } } var child51 = new Child5() var child52 = new Child5() child51.reName() console.log(child51.name, child52.name) // [ 'super5', 'new 5' ], 子类实例不会相互影响 console.log(child51.reName === child52.reName) //true, 共享了父类的方法 child51.__proto__ ----> Child5.prototype ----> Parent5.prototype ----> Object.prototype ----> null child52.__proto__ ----> Child5.prototype ----> Parent5.prototype ----> Object.prototype ----> null "},"css/":{"url":"css/","title":"CSS","keywords":"","body":"CSS "},"css/01.html":{"url":"css/01.html","title":"响应式&自适应","keywords":"","body":"响应式和自适应 响应式： 流动网格布局 自适应： 使用固定分割点来进行布局 link @import @import url(\"tinyScreen.css\") screen and (max-device-width: 400px); @media multiple features: @media screen and (min-width: 30em) and (orientation: landscape) { ... } multiple queries: @media (min-height: 680px), screen and (orientation: portrait) { ... } flex 容器属性 flex-direction flex-wrap flex-flow flex-flow: ; justify-content space-evenly align-items 定义项目在轴上如何对齐。 align-content 定义了轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content 单轴时 项目属性 order 属性定义项目的排列顺序 flex-grow 属性定义项目的放大比例 flex-shrink 属性定义了项目的缩小比例 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间 flex flex: align-self 重写align-items，属性允许单个项目有与其他项目不一样的对齐方式 font-size响应式 px：像素（Pixel）。相对长度单位，所占大小由屏幕分辨率决定。 em：相对长度单位。相当于当前对象内文本的字体尺寸。 rem：CSS3新增的一个相对单位。rem是相对于根元素。 如果浏览器默认字号是16，换算规则： px rem 12 12/16 = .75 14 14/16 = .875 16 16/16 = 1 18 18/16 = 1.125 20 20/16 = 1.25 24 24/16 = 1.5 30 30/16 = 1.875 36 36/16 = 2.25 42 42/16 = 2.625 48 48/16 = 3 图片自适应 windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： img { -ms-interpolation-mode: bicubic; } 或者 addLoadEvent(function() { 　　var imgs = document.getElementById(\"content\").getElementsByTagName(\"img\"); 　　imgSizer.collate(imgs); }); 或者根据不同大小的屏幕，加载不同分辨率的图片。 http://blog.cloudfour.com/responsive-imgs-part-2/ postcss-pxtorem module.exports = { plugins: { autoprefixer: { browsers: ['Android >= 4.0', 'iOS >= 8'], }, 'postcss-pxtorem': { rootValue: 37.5, propList: ['*'], }, }, }; "},"css/3d.html":{"url":"css/3d.html","title":"3D与动画","keywords":"","body":"3D与动画 动画 @keyframes animationname keyframes-selector(0-100%, from, to) css-styles animation name duration (2s) timing-function (ease-in-out) delay (2s,可以为负数) iteration-count (infinite) direction (reverse) fill-mode (动画结束时的状态) play-state (运行，暂停) 2D/3D 转换属性 transform transform-origin transform-style 遮挡关系(flat , preserve-3d) perspective 值越小景越深 perspective-origin backface-visibility 背面是否可见 过渡（Transition） 属性 transition transition-property transition-duration transition-timing-function transition-delay "},"css/css.html":{"url":"css/css.html","title":"css选择器","keywords":"","body":"css选择器 看到了这一篇https://juejin.im/post/5e6b2b9ce51d4526fd069b87 所以CSS选择器查缺补漏，安排上 基础 element1~element2 选择element1之后的每一个element2 a[src^=\"https\"] 选择每一个src属性的值以\"https\"开头的元素 a[src$=\".pdf\"] 选择每一个src属性的值以\".pdf\"结尾的元素 a[src*=\"runoob\"] 选择每一个src属性的值包含子字符串\"runoob\"的元素 p:first-of-type 选择每个p元素是其父级的第一个p元素 p:last-of-type 选择每个p元素是其父级的最后一个p元素 p:only-of-type 选择每个p元素是其父级的唯一p元素 p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素 :not(p) 选择每个并非p元素的元素 特殊 p:only-child 选择每个p元素是其父级的唯一子元素 p:empty 选择每个没有任何子级的p元素（包括文本节点） :target 选择当前锚点 :root 选择文档的根元素,在HTML中根元素始终是HTML元素。 ::selection 匹配元素中被用户选中或处于高亮状态的部分 表单 input:enabled 选择每一个已启用的输入元素，与input:disabled相反 input:optional 用于匹配可选的输入元素 和:required相反 :valid 用于匹配输入值为合法的元素和:invalid相反 组合 1. :active伪类与CSS数据上报 .button-1:active::after { content: url(./pixel.gif?action=click&id=button1); display: none; } .button-2:active::after { content: url(./pixel.gif?action=click&id=button2); display: none; } 2. 超实用超高频使用的:empty 伪类 2.1 隐藏空元素 .cs-module:empty { display: none; } 2.2 字段缺失智能提示 td:empty::before{ content: '-'; color: gray; } 公共类 .cs-search-module:empty::before{ content: '没有搜索结果'； display: block; line-height: 300px; text-align: center; color: gray; } 3. 用好:only-child伪类 正在加载中... 正在加载中... .cs-loading { height: 150px; position: relative; text-align: center; /* 与截图无关，截图示意用 */ border: 1px dotted; } /* 图片和文字同时存在时在中间留点间距 */ .cs-loading-img { width: 32px; height: 32px; margin-top: 45px; vertical-align: bottom; } .cs-loading-p { margin: .5em 0 0; color: gray; } /* 只有图片的时候居中绝对定位 */ .cs-loading-img:only-child { position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } /* 只有文字的时候行号近似垂直居中 */ .cs-loading-p:only-child { margin: 0; line-height: 150px; } "},"css/less_and_sass.html":{"url":"css/less_and_sass.html","title":"Less and Sass","keywords":"","body":"Less and Sass Less 变量 @width: 10px; @height: @width + 10px; #header { width: @width; height: @height; } 任何 ~\"anything\" 或 ~'anything' 形式的内容都将按原样输出，除非 interpolation。 @min768: ~\"(min-width: 768px)\"; .element { @media @min768 { font-size: 1.2rem; } } // or 从 Less 3.5 开始，可以简写为： @min768: (min-width: 768px); .element { @media @min768 { font-size: 1.2rem; } } URLs // Variables @images: \"../img\"; // Usage body { color: #444; background: url(\"@{images}/white-sand.png\"); } 变量嵌套 @primary: green; @secondary: blue; .section { @color: primary; .element { color: @@color; } } 使用已有属性的值 .widget { color: #efefef; background-color: $color; } mixin .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; } #menu a { color: #111; .bordered(); } 可以通过中括号查看mixin里的属性mixin[prop];，如果是空括号[]就会查询最后一条。 mixin中的变量能被调用者访问到, 作用域范围在调用者的大括号中。 .mixin() { @width: 100%; @height: 200px; } .caller { .mixin(); width: @width; height: @height; } 转译成 .caller { width: 100%; height: 200px; } 带参数 .border-radius(@radius) { -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius; } 默认值 .border-radius(@radius: 5px) { -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius; } @arguments .box-shadow(@x: 0; @y: 0; @blur: 1px; @color: #000) { -webkit-box-shadow: @arguments; -moz-box-shadow: @arguments; box-shadow: @arguments; } .big-block { .box-shadow(2px; 5px); } @rest .mixin(...) { // matches 0-N arguments .mixin() { // matches exactly 0 arguments .mixin(@a: 1) { // matches 0-1 arguments .mixin(@a: 1; ...) { // matches 0-N arguments .mixin(@a; ...) { // matches 1-N arguments .mixin(@a; @rest...) { // @rest is bound to arguments after @a // @arguments is bound to all arguments } 集合 #bundle() { .button { display: block; border: 1px solid black; background-color: grey; &:hover { background-color: white; } } .tab { ... } .citation { ... } } #header a { color: orange; #bundle.button(); // 还可以书写为 #bundle > .button 形式 } 将Mixin作为函数 .average(@x, @y) { @result: ((@x + @y) / 2); } div { // 调用@result并查询@result的值 padding: .average(16px, 50px)[@result]; } 循环loop .generate-columns(4); .generate-columns(@n, @i: 1) when (@i = 转译为 .column-1 { width: 25%; } .column-2 { width: 50%; } .column-3 { width: 75%; } .column-4 { width: 100%; } 匹配 .mixin(dark; @color) { color: darken(@color, 10%); } .mixin(light; @color) { color: lighten(@color, 10%); } .mixin(@_; @color) { display: block; } @switch: light; .class { .mixin(@switch; #888); } 因为.mixin(@switch; #888)既符合.mixin(light; @color)又符合.mixin(@_; @color)，所以转译成 .class { color: #a2a2a2; display: block; } 映射Map #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } @import // Variables @themes: \"../../src/themes\"; // Usage @import \"@{themes}/tidal-wave.less\"; @import \"library\"; // library.less @import \"typo.css\"; & 如果插在&前面 .header { .menu { border-radius: 5px; .no-borderradius & { background-image: url('images/button-background.png'); } } } 转译成 .header .menu { border-radius: 5px; } .no-borderradius .header .menu { background-image: url('images/button-background.png'); } p, a, ul, li { border-top: 2px dotted #366; & + & { border-top: 0; } } 转成 p, a, ul, li { border-top: 2px dotted #366; } p + p, p + a, p + ul, p + li, a + p, a + a, a + ul, a + li, ul + p, ul + a, ul + ul, ul + li, li + p, li + a, li + ul, li + li { border-top: 0; } extend nav ul { &:extend(.inline); background: blue; } .inline { color: red; } .a:extend(.b) {} // 等价于 .a { &:extend(.b); } .c:extend(.d all) { // 继承所有的\".d\" 包括\".x.d\"和\".d.x\" } .c:extend(.d) { // 只继承\".d\" } .e:extend(.f) {} .e:extend(.g) {} // 等价于 .e:extend(.f, .g) {} 合并 用+ or +_ 标志 .mixin() { box-shadow+: inset 0 0 10px #555; } .myclass { .mixin(); box-shadow+: 0 0 20px black; } 转译成带逗号 .myclass { box-shadow: inset 0 0 10px #555, 0 0 20px black; } .mixin() { transform+_: scale(2); } .myclass { .mixin(); transform+_: rotate(15deg); } 转译成带空格 .myclass { transform: scale(2) rotate(15deg); } less函数 Sass scss与sass的区别 SCSS 语法使用 .scss 文件扩展名。除了极少部分的例外， 它是 CSS 的超集，也就是说 所有有效的 CSS 也同样都是有效的 SCSS 。 CSS 规定了如何从大多数错误中恢复， 而不是立即失败。 缩进语法是 Sass 的原始语法，因此它使用文件 扩展名 .sass 。由于这个扩展名的原因，这种语法有时直接被称为 “Sass\"。 Sass 样式表是经由 Unicode 编码序列解析而来的。 解析是直接进行的，没有转换为标记流（token stream）的过程。 当 Sass 在样式表中遇到无效语法时，解析将失败， 并向用户展示错误信息。 //SCSS有花括号 // This comment won't be included in the CSS. /* But this comment will, except in compressed mode. */ @mixin button-base() { @include typography(button); &:hover { cursor: pointer; } &:disabled { color: $mdc-button-disabled-ink-color; cursor: default; pointer-events: none; } } //SASS用缩进 // This comment won't be included in the CSS. This is also commented out. /* But this comment will, except in compressed mode. @mixin button-base() @include typography(button) &:hover cursor: pointer &:disabled color: $mdc-button-disabled-ink-color cursor: default pointer-events: none 嵌套 属性也是可以嵌套的 p { 　　border: { 　　　　color: red; 　　} } 变量 $myFont: Helvetica, sans-serif; // 全局作用域 body { $myFontSize: 18px; // 局部作用域 $myColor: green !global; // 全局作用域 font-family: $myFont; font-size: $myFontSize; } p { color: $myColor; } 映射Map @use \"sass:map\"; $theme-colors: ( \"success\": #28a745, \"info\": #17a2b8, \"warning\": #ffc107, ); .alert { // Instead of $theme-color-#{warning} background-color: map.get($theme-colors, \"warning\"); } @use @use with (: , : ) // _library.sass $black: #000 !default $border-radius: 0.25rem !default $box-shadow: 0 0.5rem 1rem rgba($black, 0.15) !default code border-radius: $border-radius box-shadow: $box-shadow // style.sass @use 'library' with ($black: #222, $border-radius: 0.1rem) 转译成 code { border-radius: 0.1rem; box-shadow: 0 0.5rem 1rem rgba(34, 34, 34, 0.15); } @use \"sass:math\" as math // This assignment will fail. math.$pi: 0 & .alert { &:hover { font-weight: bold; } [dir=rtl] & { margin-left: 0; margin-right: 10px; } :not(&) { opacity: 0.8; } } 转换成 .alert:hover { font-weight: bold; } [dir=rtl] .alert { margin-left: 0; margin-right: 10px; } :not(.alert) { opacity: 0.8; } placeholder % %toolbelt不会被编译成选择器，只能和@extended一起用。 %toolbelt { box-sizing: border-box; border-top: 1px rgba(#000, .12) solid; padding: 16px 0; width: 100%; &:hover { border: 2px rgba(#000, .5) solid; } } .action-buttons { @extend %toolbelt; color: #4285f4; } .reset-buttons { @extend %toolbelt; color: #cddc39; } @import 在文件名的开头添加一个下划线，Sass 的代码文件就不会编译到一个 CSS 文件。 带下划线与不带下划线的同名文件放置在同一个目录下，比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下， 否则带下划线的文件将会被忽略。 @import \"variables\"; @import \"colors\"; @import \"reset\"; @mixin 与 @include @mixin 指令允许我们定义一个可以在整个样式表中重复使用的样式。 @include 指令可以将混入（mixin）引入到文档中。 // 连接符号 - 与下划线符号 _ 是相同的，也就是 @mixin important-text { } 与 @mixin important_text { } 是一样的混入。 @mixin important-text { color: red; font-size: 25px; font-weight: bold; border: 1px solid blue; } .danger { @include important-text; background-color: green; } //混入中也可以包含混入 @mixin special-text { @include important-text; @include link; @include special-border; } // 混入传参 @mixin bordered($color, $width) { border: $width solid $color; } .myArticle { @include bordered(blue, 1px); // 调用混入，并传递两个参数 } // 混入传参默认值 @mixin sexy-border($color, $width: 1in) { border: { color: $color; width: $width; style: dashed; } } // 不确定参数个数，用... @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); } //适配浏览器前缀 @mixin transform($property) { -webkit-transform: $property; -ms-transform: $property; transform: $property; } .myBox { @include transform(rotate(20deg)); } @extend 与 继承 如果一个样式与另外一个样式几乎相同，只有少量的区别，则使用 @extend，告诉 Sass 一个选择器的样式从另一选择器继承。 .button-basic { border: none; padding: 15px 30px; text-align: center; font-size: 16px; cursor: pointer; } .button-report { @extend .button-basic; background-color: red; } .button-submit { @extend .button-basic; background-color: green; color: white; } 控制流 @for in @for $i from 1 to 10 { 　　　　.border-#{$i} { 　　　　　　border: #{$i}px solid blue; 　　　　} 　　} @while $i: 6; 　　@while $i > 0 { 　　　　.item-#{$i} { width: 2em * $i; } 　　　　$i: $i - 2; 　　} @each @mixin prefix($property, $value, $prefixes) @each $prefix in $prefixes -#{$prefix}-#{$property}: $value #{$property}: $value .gray @include prefix(filter, grayscale(50%), moz webkit) @if $rounded-corners: false; .button { border: 1px solid black; border-radius: if($rounded-corners, 5px, null); } $dark-theme: true !default @if $dark-theme $primary-color: darken($primary-color, 60%) $accent-color: lighten($accent-color, 60%) sass函数 SASS封好的一些方法。 https://www.runoob.com/sass/sass-functions.html 自定义属性 $primary: #81899b; $accent: #302e24; $warn: #dfa612; :root { --primary: #{$primary}; --accent: #{$accent}; --warn: #{$warn}; // Even though this looks like a Sass variable, it's valid CSS so it's not evaluated. --consumed-by-js: $primary; } 自定义函数 @function double($n) { 　　@return $n * 2; } #sidebar { 　　width: double(5px); } "},"css/cssfont.html":{"url":"css/cssfont.html","title":"css属性","keywords":"","body":"CSS字体 属性 字体 font \"font-style font-variant font-weight font-size/line-height font-family\" font-style normal italic oblique inherit font-variant normal small-caps inherit font-weight font-size/line-height font-family 段落 direction && writing-mode writing-mode样式多， IE兼容性不好 letter-spacing && word-spacing 字符间距 单词距离 text-transform capitalize uppercase lowercase vertical-align white-space pre(原格式，超出不断行) nowrap(直到遇到break) pre-wrap(保留空格断行) pre-line(合并空格，保留换行) text-align-last 文本最后一行 word-break normal(浏览器) break-all(随意) keep-all(半角空格或连字符处) word-wrap break-word(在长单词或 URL 地址内部进行换行) 自定义字体 @font-face @font-face { font-family: myFirstFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9 */ } 安全字体 \"安全字体\"，因为它可以保证所有用户的视觉效果是一样的。 Serif 字体 文本示例 Georgia, serif 这是标题This is a paragraph \"Palatino Linotype\", \"Book Antiqua\", Palatino, serif 这是标题This is a paragraph \"Times New Roman\", Times, serif 这是标题This is a paragraph sans - serif字体 文本示例 Arial, Helvetica, sans-serif 这是标题This is a paragraph Arial Black, Gadget, sans-serif 这是标题This is a paragraph \"Comic Sans MS\", cursive, sans-serif 这是标题This is a paragraph Impact, Charcoal, sans-serif 这是标题This is a paragraph \"Lucida Sans Unicode\", \"Lucida Grande\", sans-serif 这是标题This is a paragraph Tahoma, Geneva, sans-serif 这是标题This is a paragraph \"Trebuchet MS\", Helvetica, sans-serif 这是标题This is a paragraph Verdana, Geneva, sans-serif 这是标题This is a paragraph Monospace 字体 文本示例 \"Courier New\", Courier, monospace 这是标题This is a paragraph \"Lucida Console\", Monaco, monospace 这是标题This is a paragraph "},"css/cssattr.html":{"url":"css/cssattr.html","title":"css字体","keywords":"","body":"CSS属性 @ @charset 定义样式表使用的字符集，比如content中使用。 @import 告诉 CSS 引擎引入一个外部样式表。@import url list-of-media-queries; @namespace 告诉 CSS 引擎必须考虑XML命名空间。 @media 如果满足媒介查询的条件则条件规则组里的规则生效。 @page 描述打印文档时布局的变化。 @font-face 描述将下载的外部的字体。 @keyframes 描述 CSS 动画的中间步骤。 @supports 特性查询，如果满足给定条件则条件规则组里的规则生效，ie不兼容。 @document 如果文档样式表满足给定条件则条件规则组里的规则生效。 function expression() ie5+ calc() min() min(40%, 400px)兼容不及calc() max() max(40%, 400px)兼容不及calc() clamp() clamp(1rem, 2.5vw, 1.5rem)兼容不及calc() attr() attr(data-width px, inherit); 兼容性 背景 background bg-color bg-image position/bg-size bg-repeat bg-origin (相对位置padding-box border-box content-box) bg-clip (绘制范围padding-box border-box content-box) bg-attachment (背景图像是否固定或者随着页面的其余部分滚动) background-position用top 或0px时都是以背景和盒子的左上角的原点。用百分比时，是图片本身（x%,y%）的那个点，与背景区域的（x%,y%）的那个点重合 border source slice(向内偏移截取) width outset repeat border-style dotted dashed solid double groove(外凹中凸) ridge(外凸中凹) inset(凹槽) outset(凸起) border-image source slice(留下边角，中间掏空) width outset(边框外移程度) repeat 三角形 div {width: 0;height: 0;border: 40px solid;border-color: transparent transparent red;} outline 1. 和border顺序相反(先颜色最后宽度)2. 在border之外3. outline-offset偏移距离(兼容性) 内容生成 counter-increment 在元素前面添加编号counter-increment:section; content:\"Section\" counter(section) \". \"; counter-reset 最顶级是body编号为0，所以去掉0，就给body加上reset quotes 设置嵌套引用的引号类型 list list-style list-style-type list-style-position (inside, outside ) list-style-image. 多列(Multi-column) 属性 column-count 列数 column-gap column-rule column-rule-width column-rule-style column-rule-color columns column-width(默认auto) column-count; 定位（Positioning） 属性 position relative(相对于其正常位置进行定位) clip 搭配fixed和absolute用(和padding的区别是，padding-box里还看得到，但clip区域外是透明的) float && clear 浮动 && 清除浮动 分页（Print） 属性 打印时才生效 page-break-before && page-break-after && page-break-inside(元素中) 分页符 表格（Table） 属性 border-collapse collapse(合并重复边框) separate border-spacing cell间距 empty-cells 空单元格(hide, show) table-layout 宽度fixed automatic WebKit Extensions -webkit-line-clamp 把块容器中的内容限制为指定的行数。溢出缩略... -webkit-tap-highlight-color 设置点击链接的时候出现的高亮颜色 "},"vue/":{"url":"vue/","title":"VUE","keywords":"","body":"Vue笔记 遇到的几个vue的问题，答不上来 源码 虚拟dom vue.delete provide/inject $attr, $listener transition，transition-group 重新看了文档之后的问题 passive修饰符 浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，导致页面卡顿。passive 的意思是“顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了。 passive 监听器能保证的只有一点，那就是调用 preventDefault() 无效. 想起从前项目中的一个bug，element-ui表格按字母表分类，array变化后显示有问题。 Vue.config.optionMergeStrategies 响应式原理 把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。 getter/setter让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。 Vue 在更新 DOM 时是异步执行的。如果同一个 watcher 被多次触发，会去重再将实际操作放入队列中，等待DOM刷新。所以如果想操作数据刷新后的DOM应该在nextTick中进行。 nextTick返回Promise对象，所以可以await this.$nextTick() vue 实例 只有当实例被创建时就已经存在于 data 中的属性才是响应式的。如果你知道你会在晚些时候需要一个属性，那么你仅需要设置一些初始值。 不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod())，因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止。 不需要关注变化就Object.freeze()。 模板语法 Vue 将模板编译成 虚拟DOM 渲染函数，计算出最少需要重新渲染多少组件。 每个绑定都只能包含单个表达式，所以if (ok) { return message } var a = 1都不会生效。模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 v-html只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值，容易导致 XSS 攻击。 ... 中括号内不可以有空格引号，动态attributeName考虑用Computed实现 attributeName预期String，异常时为null，其他情况触发警告 计算属性和侦听器 Computed是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 Methods总会再次执行函数。 Watch是Computed备选，Computed解决不了时再watch，比如：当需要在数据变化时执行异步或开销较大的操作时。 Class 与 Style 绑定 可以放String, Array, Object //这样写只会渲染数组中最后一个被浏览器支持的值。 v-if, v-show, v-once条件渲染 添加key是为了让两个元素独立，不复用。 v-show 不支持 元素， v-if有销毁重建，v-show仅仅是隐藏显示。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。最好是直接将列表过滤之后再循环。 v-for列表渲染 遍历对象时{value, key, index}第三个参数是index。 不要使用对象或数组之类的非基本类型值作为 v-for 的 key 。请用字符串或数值类型的值。 过滤 even是个function。 Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue vm.$set(vm.items, indexOfItem, newValue) vm.items.splice(indexOfItem, 1, newValue) vm.userProfile = Object.assign({}, vm.userProfile, obj) 当你修改数组的长度时，例如：vm.items.length = newLength vm.items.splice(newLength) // 我还以为可以直接把数组变长，然而其实并不行 // splice(start, deleteCount, item1, item2...) // deleteCount省略，start之后数组的所有元素都会被删除。 // start超出长度向末尾添加，负数从末尾删除。 let arr = [1,2,3,4,5,6] arr.splice(8) console.log(arr) //[1, 2, 3, 4, 5, 6] let arr = [1,2,3,4,5,6] arr.splice(-8) console.log(arr) //[] let arr = [1,2,3,4,5,6] arr.splice(3) console.log(arr) //[1, 2, 3] v-on:event事件处理 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： Submit v-model表单输入绑定 v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。 自定义v-model model: { prop: 'checked', event: 'change' } text 和 textarea 元素使用 value 属性和 input 事件；input和change的区别是会影响中文输入。 checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 number 修饰符返回number类型 组件基础 一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。 为了满足元素嵌套规则可以写成 组件注册(同理router引入全部文件) 组件和路由自动化 https://www.daozhao.com/8605.html // require.context(directory, useSubdirectories = true, regExp = /^\\.\\/.*$/, mode = 'sync'); // mode可选\"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\" // sync || eager: just add all dependencies and continue // lazy-once: create a new async dependency block and add that block to this context // lazy: a new async dependency block per dependency and add all blocks to this context // weak || async-weak: we mark all dependencies as weak const requireComponent = require.context( './components', // 其组件目录的相对路径 false, // 是否查询其子目录 /Base[A-Z]\\w+\\.(vue|js)$/ // 匹配基础组件文件名的正则表达式 ) requireComponent.keys().forEach(fileName => { console.log(requireComponent(fileName)) }) Prop 验证 prop: { type: '字符串或数组', validator: function (value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } // prop 会在一个组件实例创建之前进行验证，所以实例的属性 (如 data、computed 等) 在 default 或 validator 函数中是不可用的。 传入所有属性等价于 对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=\"text\" 就会替换掉 type=\"date\" 并把它破坏！庆幸的是，class 和 style 有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素。 自定义事件 model: { prop: 'checked' //默认value, event: 'change' //默认input } $listeners里面包含了作用在这个组件上的所有监听器。通过Computed + Object.assign({}, this.$listener) + v-on可以重写事件。 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。 这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 插槽 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 SubmitSubmit就是默认的placeholder。 注意 v-slot 只能添加在 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。 作用域插槽用法，解构 ... // 解构 {{ person.firstName }} // 默认值 {{ user.firstName }} 动态组件 & 异步组件 keep-alive 注意这个 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。 异步组件 components: { a: require(['./my-async-component'], resolve), b: () => import('./my-async-component'), c: () => ({ // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000 }) } 处理边界情况 应该避免在模板或计算属性中访问 $refs。 依赖注入 provide 和 inject provide中的属性和方法可以被后代访问到。 循环(组件是调用自身) 等到beforeCreate载绑上去 beforeCreate: function () { this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default } 异步 components: { TreeFolderContents: () => import('./tree-folder-contents.vue') } 程序化时间侦听hook:beforeDestroy mounted: function () { this.attachDatepicker('startDateInput') this.attachDatepicker('endDateInput') }, methods: { attachDatepicker: function (refName) { var picker = new Pikaday({ field: this.$refs[refName], format: 'YYYY-MM-DD' }) this.$once('hook:beforeDestroy', function () { picker.destroy() }) } } 过渡 & 动画 过渡和动画是两个事件，用type（可选值animation||transition）来确定监听transitionend和animationend 钩子 mixin混入 和组件都是复用，但区别是this，可以用在比如发送短信60s。 渲染函数 &JSX 新建[[h1-6]]标签时，省去v-if判断this.level render: function (createElement) { return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 子节点数组 ) } 虚拟DOM，JSX，函数式组件 看不懂 API config optionMergeStrategies keyCodes Vue.set和Vue.delete 还是不懂为什么要删掉，我感觉日常把它设为空就好了，或许是用在数组套对象的时候，没用过，先记下来。 data 如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。 provide / inject provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 用Vue.observable可以使其响应式 const state = Vue.observable({ count: 0 }) const Demo = { render(h) { return h('button', { on: { click: () => { state.count++ }} }, `count is: ${state.count}`) } } watch 停止监听，但是immediate: true的第一次无法取消监听。 var unwatch = vm.$watch( 'value', function () { doSomething() if (unwatch) { unwatch() } }, { immediate: true } ) forceUpdate 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 "},"vue/通信.html":{"url":"vue/通信.html","title":"通信","keywords":"","body":"通信 https://juejin.im/post/5d267dcdf265da1b957081a3 props / $emit $children / $parent / $refs provide / inject provide和inject不是响应式的，这点很重要，除非申明的属性是响应式的！ C是B的子组件，B是A的子组件 // A.vue import comB from '../components/test/comB.vue' export default { name: \"A\", provide: { for: \"demo\" }, components:{ comB } } // B.vue {{demo}} import comC from '../components/test/comC.vue' export default { name: \"B\", inject: ['for'], data() { return { demo: this.for } }, components: { comC } } eventBus 1 初始化 // event-bus.js import Vue from 'vue' export const EventBus = new Vue() import showNumCom from './showNum.vue' import additionNumCom from './additionNum.vue' export default { components: { showNumCom, additionNumCom } } 2 发送事件 // addtionNum.vue 中发送事件 +加法器 import {EventBus} from './event-bus.js' console.log(EventBus) export default { data(){ return{ num:1 } }, methods:{ additionHandle(){ EventBus.$emit('addition', { num:this.num++ }) } } } 3 接收事件 // showNum.vue 中接收事件 计算和: {{count}} import { EventBus } from './event-bus.js' export default { data() { return { count: 0 } }, mounted() { EventBus.$on('addition', param => { this.count = this.count + param.num; }) } } 4 移除事件监听者 import { eventBus } from 'event-bus.js' EventBus.$off('addition', {}) Vuex localStorage / sessionStorage $attrs与 $listeners "},"vue/双向绑定.html":{"url":"vue/双向绑定.html","title":"双向绑定","keywords":"","body":"双向绑定Object.defineProperty和Proxy Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 https://www.cnblogs.com/canfoo/p/6891868.html https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90 proxy "},"http/":{"url":"http/","title":"HTTP","keywords":"","body":"HTTP "},"ts/":{"url":"ts/","title":"TypeScript","keywords":"","body":"TypeScript笔记 对值所具有的结构进行类型检查。基础类型 ``` // boolean let isDone: boolean = false; // number let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; //string let name: string = \"bob\"; let sentence: string = `Hello, my name is ${ name }. //array let list: number[] = [1, 2, 3]; let list: any[] = [1, true, \"free\"]; let list: Array = [1, 2, 3]; //元组 Tuple 按顺序 let x: [string, number]; x = ['hello', 10]; // OK x = [10, 'hello']; // Error //枚举 //使用枚举类型可以为一组数值赋予友好的名字，默认情况下，从0开始为元素编号。 enum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; console.log(colorName); // 显示'Green'因为上面代码里它的值是2 //Any let notSure: any = 4; notSure = \"maybe a string instead\"; notSure = false; // okay, definitely a boolean //Void，Null 和 Undefined //没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void //null和undefined是所有类型的子类型，可以把 null和undefined赋值给number类型的变量 function warnUser(): void { console.log(\"This is my warning message\"); } let unusable: void = undefined; let u: undefined = undefined; let n: null = null; //Never //never类型表示的是那些永不存在的值的类型。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } //Object 表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 ## 变量声明 ### 解构函数 function f([first, second]: [number, number]) { console.log(first); console.log(second); } f(input); let {a, b}: {a: string, b: number} = o; function keepWholeObject(wholeObject: { a: string, b?: number }) { let { a, b = 1001 } = wholeObject; } ## 接口 为类型命名和为你代码定义契约。 类型检查器会查看`printLabel`的调用。 `printLabel`有一个参数，并要求这个对象参数有一个名为`label`类型为`string`的属性。 function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label); } let myObj = { size: 10, label: \"Size 10 Object\" }; printLabel(myObj); ``` "},"react/":{"url":"react/","title":"React","keywords":"","body":"React笔记 文档： https://create-react-app.dev/docs/getting-started 路由 问题一：编程式导航，this.props.history 得到 undefined 路由组件 (经过路由匹配渲染的组件) 可以直接获取这些属性，而非路由组件就必须通过withRouter修饰后才能获取这些属性了 非路由组件需要路由参数时，使用withRouter给此组件传入路由参数，可以将react-router的 history、location、match 三个对象传入不是通过路由切换过来的组件的props对象上，使得被修饰的组件可以从属性中获取history,location,match import React from \"react\"; import {withRouter} from \"react-router-dom\"; class MyComponent extends React.Component { ... myFunction() { this.props.history.push(\"/some/Path\"); } ... } export default withRouter(MyComponent); 问题二：switch用法 路由变了，新组件没有挂载，去掉就可以跳了 因为switch需要搭配exact用 比如\"/\"，\"/search\"，\"/account\"，那么search和account可以视作是/的子路由，那么点击search或account还是会就近匹配到/。 组件 相对路径改绝对路径 // jsconfig.json { \"compilerOptions\": { \"baseUrl\": \"src\" }, \"include\": [\"src\"] } css模块化 https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/ 多个classclassName={${style.btn} ${style.btn1}} // Button.module.css .error { background-color: red; } // #another-stylesheet.css .error { color: red; } // #Button.js import React, { Component } from 'react'; import styles from './Button.module.css'; // Import css modules stylesheet as styles import './another-stylesheet.css'; // Import regular stylesheet class Button extends Component { render() { // reference as a js object return Error Button; } } 传值和方法 父调用子方法 // this.refs['child']拿到子实力，拿去值和方法 子调用父方法 {FuntionA}}> // 子组件调用this.props.functionName(), 父组件就会运行FuntionA() ant mobile tabs sticky 我就说为什么抄的还能错，renderTabBar我写成了renderTab，土拨鼠啊.jpg ( {({ style }) => ( )} )} onChange={(tab, index) => { console.log('onChange', index, tab); }} > {this.state.tabs.map((item, index) => { return ; })} listview 写完这个已经从fury到佛系了，(￣_,￣ ) class Index extends React.Component { constructor(props) { super(props); this.state = { list: [ { img: 'https://zos.alipayobjects.com/rmsportal/dKbkpPXKfvZzWCM.png', title: 'Meet hotel', des: '不是所有的兼职汪都需要风吹日晒' }, { img: 'https://zos.alipayobjects.com/rmsportal/XmwCzSeJiqpkuMB.png', title: \"McDonald's invites you\", des: '不是所有的兼职汪都需要风吹日晒' }, { img: 'https://zos.alipayobjects.com/rmsportal/hfVtzEhPzTUewPm.png', title: 'Eat the week', des: '不是所有的兼职汪都需要风吹日晒' } ], isLoading: false, hasMore: true, refreshing: true, dataSource: new ListView.DataSource({ rowHasChanged: (row1, row2) => row1 !== row2 }) }; } render() { let { list, dataSource, isLoading, refreshing } = this.state; return ( ( {rowData.des} )} renderBodyComponent={(props) => ( {props} )} renderSeparator={(sectionID, rowID) => } renderFooter={() => ( {isLoading ? '加载中...' : '加载完成'} )} onEndReached={this.onEndReached} onEndReachedThreshold={10} pullToRefresh={ { this.setState({ refreshing: true }); setTimeout(() => { this.setState({ refreshing: false }); }, 1000); }} /> } /> ); } componentDidMount() { this.getData(); } onEndReached = (event) => { if (this.state.isLoading || !this.state.hasMore) { return; } this.getData(); }; getData() { this.setState({ isLoading: true }); setTimeout(() => { let list = this.state.list.concat(this.state.list); this.setState({ list, isLoading: false, hasMore: list.length "},"jekyll/":{"url":"jekyll/","title":"jekyll","keywords":"","body":"jekyll 记录用jekyll建博中遇到的麻烦，主要是墙 系统: mac Mojave 参考: （中文文档）http://jekyllcn.com/ （英文文档）https://jekyllrb.com （参考三）https://alligator.io/jekyll/ （参考四：从无到有全过程，这不是我的重点）https://blog.csdn.net/qq_19799765/article/details/80869363和https://zhuanlan.zhihu.com/p/28321740 模版 图省事，从https://github.com/jekyll/minima拷了文件，想照着readme直接bundle exec jekyll serve运行，结果报错说不认识bundle 和 jekyll。 You can find and preview themes on different galleries: jamstackthemes.dev jekyllthemes.org jekyllthemes.io jekyll-themes.com 安装bundle和jekyll 按照jekyll文档gem install jekyll bundler报错，最后找到原因 一号墓坑: mac Ruby要 > 2.4.0 Jekyll requires Ruby > 2.4.0.macOS Catalina 10.15 comes with ruby 2.6.3, so you’re fine. If you’re running a previous macOS system, you’ll have to install a newer version of Ruby. 安装Ruby https://jekyllrb.com/docs/installation/ 试了半天才发现MAC教程里的 With Homebrew和With rbenv实际上用的相同的一句，至于是不是教程写错了，咱也不敢问。 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 二号墓坑：网速是真的慢呀，十几K几K的下，怪你上网的时间不对。 因为都是With Homebrew所以就照着With Homebrew教程走到黑。 brew install ruby echo 'export PATH=\"/usr/local/opt/ruby/bin:$PATH\"' >> ~/.bash_profile ruby -v ruby 2.6.3p62 (2019-04-16 revision 67580) # 如果需要升级gem，见https://gems.ruby-china.com/ gem install jekyll bundler bundler install bundle exec jekyll serve 这里就可以运行了，后面就都是自定义样式遇到的问题。 建立集合 jekyll默认把md文件放进_post中，通过site.posts去取。如果想分类，中文和英文文档里collection这一部分都一言难尽，请参考https://alligator.io/jekyll/collections/ _config.yml collections_dir: collections collections: js: output: true title: Javasript record: output: true title: 记录 css: output: true title: Css webpack: output: true title: Webpack 改完_config.yml重新运行项目。 // 文件结构 _layout default.html home.html list.html post.html collections (和_config.yml同一层) _css (里面放md或子文件夹，注意名字里的_) _js (里面放md或子文件夹，注意名字里的_) _record (里面放md或子文件夹，注意名字里的_) _webpack (里面放md或子文件夹，注意名字里的_) 上两部结束就能site.js，site.css，site.record这样取到数组。 因为collections下有多个collection，所以我选择遍历site.collections。语法看https://shopify.github.io/liquid/。 for 循环里加上limit:3表示最多展示3个。size是数组长度。 if post.menu == undefined与第9行是我私人的判断条件，后面再解释。(起初这样写是因为不能像javascript这样!post.menu，然而写这篇文章时碰巧发现这一句还能这样写unless post.menu，见Control flow) 我希望实现的效果： 首页中展示collections（即前文_config.yml里定义的[css，js，record，webpack]） 每个collection最多展示2条，加上list.md所以limit是2。 点击collection title，就去列表页，展示collection下的post。 点击post title，就跳去详情页。 详情页post.html，是拷下来的文件里写好的。 列表页list.html照着home.html改了一下，你以为这样就完了吗？ 我在这里遇到了3号墓坑，路由怎么都不对，/collectionLabel/list返回404。 我是怎么找着原因的呢？因为/home也是404，那么就可以肯定不是按寻常/index.html， /home.html这种思路去读。这就是写list.md的理由，每个collection下都有一个list.md，每个list.md都定义permalink。如此，当路由和permalink吻合时，就能找到对应的collection下的list.md，展示正确的列表页。 _record下的list.md --- layout: list permalink: /record/list title: 记录 type: record menu: true --- 同理每一篇博文post.md需要套用post.html最为模版，menu为假。日期也可以写在文件名上，如：2011-12-31-new-years-eve-is-awesome.md --- layout: post date: 2020-03-15 --- 这样建立集合存在的问题，site.post是按时间倒序排的，site.js呈现的是正序 为了实现最新在最上，用assign my_array = collection.docs | sort: \"date\" | reverse转一下 四号墓坑：_site文件没上传，结果scss样式没有编译，bootStrap的NAV栏切换也不生效，my bad 五号墓坑：添加目录Table of Contents 六号墓坑：添加目录collepse "}}